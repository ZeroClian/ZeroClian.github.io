<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AarryList  和 LinkedList 的区别?</title>
    <url>/posts/64cd635.html</url>
    <content><![CDATA[<h1 id="AarryList-和-LinkedList-的区别"><a href="#AarryList-和-LinkedList-的区别" class="headerlink" title="AarryList  和 LinkedList 的区别?"></a>AarryList  和 LinkedList 的区别?</h1><h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><p>​    都是不同步的，也就是不保证线程安全</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><ul>
<li>ArrayList ：使用 Object 数组</li>
<li>LinkedList<ul>
<li>JDK1.6之前使用双向循环链表</li>
<li>JDK1.7取消了循环，使用双向链表</li>
</ul>
</li>
</ul>
<h2 id="其他区别"><a href="#其他区别" class="headerlink" title="其他区别"></a>其他区别</h2><ul>
<li>ArrayList <ul>
<li>支持快速随机访问</li>
<li>需要预留一定的容量空间</li>
</ul>
</li>
<li>LinkedList<ul>
<li>不支持快速随机访问</li>
<li>存储每一个元素都要消耗更多的空间</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>List、Set、Map三者的区别？</title>
    <url>/posts/a0808890.html</url>
    <content><![CDATA[<p>Java 容器分为 Collection 和 Map 两大类，Collection 集合的子接口有 Set、List、Queue 三种子接口，我们比较常用的Set、List，Map 接口不是 Collection 的子接口。<br><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/1609561439429-0560ff2e-6b53-4d14-ae32-d862c7ef10c8.png" alt="Java 容器"><br>Collection 集合主要有 List 和 Set :</p>
<ul>
<li>List ：一个有序的容器，元素可以重复，可以插入多个 null 值，元素都有索引。常用实现类为：ArrayList、LinkedList 和 Vector</li>
<li>Set ：一个无序的容器，元素不可以重复，只允许存在一个 null 值，必须保证元素唯一性。常用实现类为：HashSet、LinkedHashSet 和 TreeSet。</li>
</ul>
<p>Map 是一个键值对集合，存储键、值之间的映射。Key 无序，唯一；Value 不要求有序，可重复。常用实现类：HashMap、TreeMap、HashTable、LinkeHashMap、ConcurrentHashMap。</p>
<h2 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h2><ul>
<li>list<ul>
<li>ArrayList：Object 数组</li>
<li>LinkedList：双向循环链表</li>
<li>Vector：Object 数组</li>
</ul>
</li>
<li>Set<ul>
<li>HashSet：HashMap</li>
<li>LinkedHashSet：LinkedHashMap（内部基于HashMap）</li>
<li>TreeSet：红黑树</li>
</ul>
</li>
<li>Map<ul>
<li>HashMap： JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）.JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。</li>
<li>LinkedHashMap：LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。</li>
<li>HashTable：数组+链表</li>
<li>TreeMap：红黑树</li>
</ul>
</li>
</ul>
<h2 id="线程安全的集合类"><a href="#线程安全的集合类" class="headerlink" title="线程安全的集合类"></a>线程安全的集合类</h2><ul>
<li>vector：就比arraylist多了个同步化机制（线程安全），因为效率较低，现在已经不太建议使用。在web应用中，特别是前台页面，往往效率（页面响应速度）是优先考虑的。</li>
<li>statck：堆栈类，先进后出。</li>
<li>hashtable：就比hashmap多了个线程安全。</li>
<li>enumeration：枚举，相当于迭代器。</li>
</ul>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring IOC &amp; AOP</title>
    <url>/posts/d62ead0.html</url>
    <content><![CDATA[<h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><p>IoC（Inverse of Control 控制反转 ）是基于<strong>依赖倒置原则</strong>的一种设计思想，就是将原本由程序手动创建对象的控制权，交给 Spring 来管理。IoC 在其他语言中也有应用，并非 Spring 独有，IoC 容器是 Spring 用来实现IoC的载体，IoC 容器实际上就是一个 Map（Key，Value），用来存放各种对象。</p>
<p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器来完成对象的注入。这样可以很大程度的简化应用的开发，把应用从复杂的依赖关系中解放出来。IoC 容器就像一个工厂一样，当我们需要创建一个对象的时候，只需要配置配置文件或注解即可，完全不需要考虑对象是如何被创建出来的。</p>
<p>在实际项目中一个 Service 类可能有成百上千个类作为它的底层，如果利用 IoC 的话，只需要配置好，然后在需要的地方引用即可，大大增加了项目的可维护性，降低了开发难度。</p>
<p>IoC 采用的方法是<strong>依赖注入</strong>，即把底层类作为参数传入上层类，实现上层类对下层类的“控制”，常用的注入方式有：构造函数注入、Setter注入和接口注入。</p>
<p>而 IoC 容器可以自动对代码进行初始化，只需要通过维护一个 Configuration，使我们在创建实例时不需要去了解其中的细节。</p>
<p>Spring IoC 的初始化过程：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231104036853.png" alt="image-20201231104036853"></p>
<p>IoC 源码阅读：<a href="https://javadoop.com/post/spring-ioc">https://javadoop.com/post/spring-ioc</a></p>
<h2 id="IoC-核心思想"><a href="#IoC-核心思想" class="headerlink" title="IoC 核心思想"></a>IoC 核心思想</h2><p>IoC 的核心思想在于，资源不由使用资源的双方管理，而是由第三方管理。</p>
<p>带来的好处：</p>
<ul>
<li>资源集中管理，实现资源的可配置和易管理</li>
<li>降低使用资源双方的耦合度</li>
</ul>
<p>生活中的例子：支付宝在淘宝体系中就是一个庞大的 IoC 容器，其他代理机构。</p>
<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP（面向切面编程）能够将那些与业务无关的，却为业务模块所共同调用的逻辑或责任（如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块的耦合度，并有利于未来的可拓展性和可维护性。</p>
<p>Spring AOP 是基于动态代理的，如果要代理的对象实现了某个接口，那么 Spring AOP 就会使用 JDK Proxy 去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理，会采用 Cglib 生成一个被代理对象的子类来作为代理对象。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231105317219.png" alt="image-20201231105317219"></p>
<p>使用 AOP 之后我们就可以把通用功能抽象出来，在需要的地方直接使用，大大简化了代码量。</p>
<h2 id="Spring-AOP-和-AspectJ-AOP-有什么区别？"><a href="#Spring-AOP-和-AspectJ-AOP-有什么区别？" class="headerlink" title="Spring AOP 和 AspectJ AOP 有什么区别？"></a>Spring AOP 和 AspectJ AOP 有什么区别？</h2><p><strong>Spring AOP</strong> 属于运⾏时增强，⽽ <strong>AspectJ</strong> 是编译时增强。 Spring AOP 基于代理(Proxying)，⽽AspectJ 基于字节码操作(Bytecode Manipulation)。</p>
<p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java ⽣态系统中最完整的 AOP 框架了。AspectJ 相⽐于 Spring AOP 功能更加强⼤，但是 Spring AOP 相对来说更简单，</p>
<p>如果我们的切⾯⽐较少，那么两者性能差异不⼤。但是，当切⾯太多的话，最好选择 AspectJ ，它⽐Spring AOP 快很多。</p>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>Synchronized 关键字</title>
    <url>/posts/632b531d.html</url>
    <content><![CDATA[<h1 id="Synchronized-关键字"><a href="#Synchronized-关键字" class="headerlink" title="Synchronized 关键字"></a>Synchronized 关键字</h1><div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>参考阅读：深入理解 Java 虚拟机——JVM 高级特性与最佳实践（第十三章）</p>
</div>

<h2 id="Synchronized-的了解"><a href="#Synchronized-的了解" class="headerlink" title="Synchronized 的了解"></a>Synchronized 的了解</h2><ul>
<li>解决的是多个线程之间访问资源的同步性，保证被修饰的方法或代码块在任意时刻只能有一个线程 执行。</li>
<li>属于重量级锁，效率低下，JDK1.6之后，官方从 JVM 层面优化后，效率有所提升。</li>
</ul>
<h2 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h2><ul>
<li>修饰实例方法：作用于当前对象实例加锁，进入同步代码前要获取当前对象实例的锁。</li>
<li>修饰静态方法：给当前类加锁，作用于类的所有实例对象</li>
<li>修饰代码块：指定加锁对象，对给定对象加锁。</li>
</ul>
<p>总结：<code>synchronized</code>关键字加到<code>static</code>静态方法和<code>synchronized(class)</code>代码块上都是给Class类加锁。<code>synchronized</code>关键字加到实例方法上是给对象实例上锁。尽量不要使用<code>synchronized(String s)</code> 因为JVM中，字符串常量池具有缓存功能。</p>
<h2 id="synchronized在单例模式中的应用"><a href="#synchronized在单例模式中的应用" class="headerlink" title="synchronized在单例模式中的应用"></a>synchronized在单例模式中的应用</h2><p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton uniqueInstance;</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="title">SingletongetUniqueInstance</span><span class="params">(&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">		//先判断对象是否已经实例过，没有实例化过才进⼊加锁代码</span></span></span><br><span class="line"><span class="function"><span class="params">		<span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)</span></span>&#123;</span><br><span class="line">			<span class="comment">///类对象加锁</span></span><br><span class="line">			<span class="keyword">synchronized</span> (Singleton.class)&#123;</span><br><span class="line">				<span class="keyword">if</span>(uniqueInstance == <span class="keyword">null</span>)&#123;</span><br><span class="line">					uniqueInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">return</span> uniqueInstance;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要，uniqueInstance = new Singleton(); 这段代码其实是分三步走：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance </li>
<li>将 uniqueInstance  指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执⾏顺序有可能变成 1→3→2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致⼀个线程获得还没有初始化的实例。例如，线程 T1 执⾏了 1 和 3，此时 T2 调用getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 volatile 可以禁止指令重排，保证多线程环境下也能正常运行。</p>
</li>
</ul>
<h2 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h2><h3 id="synchronized-同步代码块原理"><a href="#synchronized-同步代码块原理" class="headerlink" title="synchronized 同步代码块原理"></a>synchronized 同步代码块原理</h3><p>Demo.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;JavaStudys&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过 JDK 自带的 javap 命令查看 Demo 类的相关字节码信息：</p>
<ul>
<li>切到类对应目录执行 <code>javac Demo.java </code>生成编译后的 .class 文件</li>
<li>执行 <code>javap -c -s -v -l Demo.class</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210104104056109.png" alt="image-20210104104056109"></p>
<p>从图可知：</p>
<p>synchronized 同步代码块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令指向同步代码块的结束位置。</p>
<p>当执行 monitorenter 指令时，线程试图获取锁也就是获取 ==monitor== 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外⼀个线程释放为止。</p>
<p>(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因)</p>
<h3 id="synchronized-修饰方法原理"><a href="#synchronized-修饰方法原理" class="headerlink" title="synchronized 修饰方法原理"></a>synchronized 修饰方法原理</h3><p>Demo2.java</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo2</span></span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;JavaStudys&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210104105619347.png" alt="image-20210104105619347"></p>
<p>synchronized 修饰的方法并没有标识 monitorenter 和 monitorexit ，而是通过 ACC_SYNCHRONIZED 标识，指明该方法是一个同步方法，JVM 通过 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<h2 id="JDK1-6-之后对-synchronized-做了哪些优化？"><a href="#JDK1-6-之后对-synchronized-做了哪些优化？" class="headerlink" title="JDK1.6 之后对 synchronized 做了哪些优化？"></a>JDK1.6 之后对 synchronized 做了哪些优化？</h2><p>JDK1.6 对锁的实现引入了大量的优化，如<u><em>偏向锁、轻量级锁、自旋锁、自适应自旋锁、锁消除、锁粗化</em></u>等技术来减少锁操作的开销。</p>
<p>锁主要存在四中状态，依次是：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>、<strong>重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级。注意锁<strong>可以升级不可降级</strong>，这种策略是为了提高获得锁和释放锁的效率。</p>
<blockquote>
<p>推荐阅读：<a href="https://zeroclian.github.io/posts/1e489958.html">https://zeroclian.github.io/posts/1e489958.html</a></p>
</blockquote>
<h2 id="synchronized-与-ReentrantLock-的区别"><a href="#synchronized-与-ReentrantLock-的区别" class="headerlink" title="synchronized 与 ReentrantLock 的区别"></a>synchronized 与 ReentrantLock 的区别</h2><h3 id="两者都是可重入锁"><a href="#两者都是可重入锁" class="headerlink" title="两者都是可重入锁"></a>两者都是可重入锁</h3><p>“可重入锁”：自己可以再次获取自己的内部锁。比如一个线程获取了某个对象的锁，此时对象的锁还没释放，当其想要再次获取这个对象的内部锁的时候还是可以获取的，如果不可重入，就会造成死锁。同一个线程每次获取锁，锁计数器都会自增1，当计数器变为0时才可释放。</p>
<h3 id="synchronized-依赖于JVM-而-ReentrantLock-依赖于API"><a href="#synchronized-依赖于JVM-而-ReentrantLock-依赖于API" class="headerlink" title="synchronized 依赖于JVM 而 ReentrantLock 依赖于API"></a>synchronized 依赖于JVM 而 ReentrantLock 依赖于API</h3><p>前面讲过，JDK1.6在 JVM 层面对 synchronized 关键字做了很多优化，但这些都是在虚拟机层面，并没有暴露给我们。而 ReentrantLock 是在 JDK 层面（API），需要通过 lock() 和 unlock() 方法配合 try/finally 语句来完成，因此可以通过源代码来查看实现方式。</p>
<h3 id="ReentrantLock-比-synchronized-增加了一些高级功能"><a href="#ReentrantLock-比-synchronized-增加了一些高级功能" class="headerlink" title="ReentrantLock 比 synchronized 增加了一些高级功能"></a>ReentrantLock 比 synchronized 增加了一些高级功能</h3><ul>
<li><p>等待可中断</p>
<p>ReentrantLock 提供了一种能够中断等待锁的线程机制，通 lock.lockInterruptibly() 来实现。即可以在等待过程选择放弃，改为处理其他事情。</p>
</li>
<li><p>可实现公平锁</p>
<p>synchronized 只能是非公平锁，ReentrantLock 可以指定公平锁还是非公平锁。所谓公平锁就是先等待先获取锁，ReentrantLock 默认是非公平，可以通过 ReentrantLock(boolean fair) 构造方法来制定是否公平。</p>
</li>
<li><p>可实现选择性通知（锁可以绑定多个条件）</p>
<p>synchronized关键字与<code>wait()</code>和<code>notify()/notifyAll()</code>方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于 <code>Condition</code> 接⼝与 <code>newCondition()</code>方法。</p>
<p><code>Condition</code>是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在⼀个Lock对象中可以创建多个<code>Condition</code>实例（即对象监视器），线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用 ReentrantLock 类结合<code>Condition</code>实例可以实现“选择性通知” ，这个功能非常重要，而且是 <code>Condition</code> 接口默认提供的。</p>
<p>而synchronized关键字就相当于整个Lock对象中只有⼀个<code>Condition</code>实例，所有的线程都注册在它⼀个身上。如果执行 <code>notifyAll()</code> 方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而<code>Condition</code>实例的 <code>signalAll()</code> 方法 只会唤醒注册在该<code>Condition</code>实例中的所有等待线程。</p>
</li>
</ul>
<p><strong>注意：</strong>JDK1.6之后性能不再是两者选择的标准</p>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode的一些骚操作</title>
    <url>/posts/34fea2ea.html</url>
    <content><![CDATA[<h2 id="一、界面美化"><a href="#一、界面美化" class="headerlink" title="一、界面美化"></a>一、界面美化</h2><blockquote>
<p>一个会动的萌妹</p>
</blockquote>
<ol>
<li>在vscode的安装目录下找到</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">resources\app\out\vs\code\electron-browser\workbench</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>用记事本打开workbench.html，将里面的内容替换为下面的代码，建议把原来的代码保存下来，以便可以换换回来。</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Copyright (C) Microsoft Corporation. All rights reserved. --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;none&#x27;; img-src &#x27;self&#x27; https: data: blob: vscode-remote-resource:; media-src &#x27;none&#x27;; frame-src &#x27;self&#x27; vscode-webview: https://*.vscode-webview-test.com; object-src &#x27;self&#x27;; script-src * &#x27;unsafe-inline&#x27; &#x27;unsafe-eval&#x27;; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; connect-src &#x27;self&#x27; https:; font-src &#x27;self&#x27; https: vscode-remote-resource:;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span></span><br><span class="line"><span class="css">		<span class="selector-id">#live2dcanvas</span> &#123;<span class="attribute">border</span>: <span class="number">0</span> <span class="meta">!important</span>;&#125;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span> <span class="attr">aria-label</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;live2d-widget&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">id</span>=<span class="string">&quot;live2dcanvas&quot;</span> <span class="attr">width</span>=<span class="string">&quot;100&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span> <span class="attr">style</span>=<span class="string">&quot;position: fixed;width:100px;height:200;opacity: 0.5;right: 0px;bottom: -20px;z-index: 99999;pointer-events: none;border:0;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Init Bootstrap Helpers --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../../../bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../../../vs/loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../../../bootstrap-window.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Startup via workbench.js --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;workbench.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/live2d-widget@3.0.4/lib/L2Dwidget.0.min.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>  <span class="attr">src</span>=<span class="string">&quot;https://cdn.jsdelivr.net/npm/live2d-widget@3.0.4/lib/L2Dwidget.min.js?_=1557308476616&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&quot;text/javascript&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript">	<span class="comment">// L2Dwidget.init();</span></span></span><br><span class="line"><span class="javascript">	  L2Dwidget.init(&#123;<span class="string">&quot;display&quot;</span>: &#123;</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;superSample&quot;</span>: <span class="number">2</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;width&quot;</span>: <span class="number">100</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;height&quot;</span>: <span class="number">200</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;position&quot;</span>: <span class="string">&quot;right&quot;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;hOffset&quot;</span>: <span class="number">0</span>,</span></span><br><span class="line"><span class="javascript">        <span class="string">&quot;vOffset&quot;</span>: <span class="number">0</span></span></span><br><span class="line">        &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">	<span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>重启vscode的就行了</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/vscode/image-20201212170125748.png" alt="image-20201212170125748"></p>
<ol start="4">
<li>恢复的话，只要把代码该回去就行</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Copyright (C) Microsoft Corporation. All rights reserved. --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span> /&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;Content-Security-Policy&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default-src &#x27;none&#x27;; img-src &#x27;self&#x27; https: data: blob: vscode-remote-resource:; media-src &#x27;none&#x27;; frame-src &#x27;self&#x27; vscode-webview: https://*.vscode-webview-test.com; object-src &#x27;self&#x27;; script-src &#x27;self&#x27; &#x27;unsafe-eval&#x27;; style-src &#x27;self&#x27; &#x27;unsafe-inline&#x27;; connect-src &#x27;self&#x27; https:; font-src &#x27;self&#x27; https: vscode-remote-resource:;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span> <span class="attr">aria-label</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Init Bootstrap Helpers --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../../../bootstrap.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../../../vs/loader.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../../../../bootstrap-window.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- Startup via workbench.js --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;workbench.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="二、代码特效"><a href="#二、代码特效" class="headerlink" title="二、代码特效"></a>二、代码特效</h2><ol>
<li>在vscode中搜索插件Power Mode，安装后重启</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/vscode/image-20201212170613027.png" alt="image-20201212170613027"></p>
<ol start="2">
<li>在设置里找到setting.json,点击编辑</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/vscode/image-20201212170835829.png" alt="image-20201212170835829"></p>
<ol start="3">
<li>在里面添加几行代码</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;powermode.enabled&quot;: true,</span><br><span class="line">&quot;powermode.presets&quot;: &quot;fireworks&quot;,   &#x2F;&#x2F;动画效果</span><br><span class="line">&quot;powermode.comboTimeout&quot;:4,       &#x2F;&#x2F; 时间间隔</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/vscode/image-20201212171012762.png" alt="image-20201212171012762"></p>
<ol start="4">
<li>重启后就有特效了</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/vscode/image-20201212171052917.png" alt="image-20201212171052917"></p>
<ol start="5">
<li>不想要只要删除代码即可（更多特效可以百度找找）</li>
</ol>
<h2 id="三、可能出现的问题"><a href="#三、可能出现的问题" class="headerlink" title="三、可能出现的问题"></a>三、可能出现的问题</h2><p>重启完成之后，我们可能会看到<strong>不受支持</strong>提示。是因为我们改动了vscode的内部代码，所以会提示。</p>
<p>我们来解决它。</p>
<p>打开命令行，安装<code>Fix VSCode Checksums</code>，键入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">code --install-extension lehni.vscode-fix-checksums</span><br></pre></td></tr></table></figure>
<p>打开vscode，快捷键 <code>Ctrl + Shift + P</code> 输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Fix Checksums:Apply</span><br></pre></td></tr></table></figure>
<p>重启Vscode，解决。</p>
<hr>
<p>本文只是代码之余的一点娱乐，打码枯燥，适当给自己增加点乐趣，想必大家写php也写累了</p>
]]></content>
      <categories>
        <category>vscode</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156.html</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="test"><a href="#test" class="headerlink" title="test"></a>test</h3><p>哪個英文字母最酷？ <span class="hide-inline"><button type="button" class="hide-button button--animated" style="background-color: #FF7242;color: #fff">查看答案
  </button><span class="hide-content">因為西裝褲(C裝酷)</span></span></p>
<p>門裏站着一個人? <span class="hide-inline"><button type="button" class="hide-button button--animated" style="">Click
  </button><span class="hide-content">閃</span></span></p>
<a class="btn-beautify button--animated blue larger" href="https://butterfly.js.org/" 
  title="Butterfly"><i class="far fa-hand-point-right fa-fw"></i><span>Butterfly</span></a>

<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>测试</tag>
        <tag>模板</tag>
      </tags>
  </entry>
  <entry>
    <title>回顾2020年</title>
    <url>/posts/97d452a7.html</url>
    <content><![CDATA[<h2 id="回顾2020年"><a href="#回顾2020年" class="headerlink" title="回顾2020年"></a>回顾2020年</h2><p>年初，突如其来的疫情，打乱了原有的计划，小时候梦想什么时候能在家学习多好，在这一年就这么实现了，但是学起来才发现，似乎并没有幻想中那么美好，老师上网课方式各种各样，手机电脑下载一堆软件，网上的课总是令人提不起精神，或许是我对这些课不感兴趣吧。</p>
<p>在家期间了也学了点别的，买了个云服务器用 SpringBoot 搭了个博客网站，但是没敢把文章放上去，生怕自己环境弄不好，一下子数据库崩了，我对数据库也不是很熟悉。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231213204148.png"></p>
<p>学了那么一阵子，突然觉得自己行了，想找份实习，于是开始投简历，投了各种级别的公司，发现自己笔试的算法题都做不出几道来，于是开始恶补数据结构和算法。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231214049340.png"></p>
<p>在 leetcode 上做了一百多道题目后，常见的题目都掌握了，刷题的脚步也停了下来，有点半途而废的感觉。学习过程中，也会写写笔记，然后放到 csdn 博客上，没想到的是大三做的一个课程设计，看和收藏的人最多，</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231214741252.png"></p>
<p>一年过去，看着博客从每个都是0，到现在</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231214936990.png"></p>
<p>感觉像是自己带大的孩子，虽然自己还是很菜，但是新的一年还是想继续坚持下去。</p>
<p>投了许多简历，也收到了一些面试的邀请，面试过程中，发现自己学的并不是很扎实，有些知识明明学过，却说不出个所以然，结果可想而知。回想自己的学习过程，似乎一直在接受新知识，却没有对已学的知识加深了解，也明白到自己要在一个方面强化自己的优势，要沉下心来。</p>
<p>很快暑假就在线上面试中过去了，迎来了大四的开学，开学也刚好让我转正，成为了一名光荣的中共党员。让我没想到的是，匿名投票选支委，居然让选了我当学生党支部副书记，没想到大家这么看好我（我怀疑有人串通，说好的民主呢）。</p>
<p>成为副书记，开启了我忙碌的大四，党务工作真是令人头大，发展党员的各种流程，入党志愿书上的各种日期和签名，生怕时间不对，写错字，这里要感谢亿阳和梓涵带我，我对这些都有阴影了。</p>
<p>好不容易弄完了发展党员，觉得可以休息一阵子好好准备面试，结果要准备检查材料，最后一天冲刺从早上9点去办公室待到晚上10点多才回的宿舍，终于搞定了，看着一桌子分类好的材料，大家都辛苦了。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231221426422.png"></p>
<p>随着事情一件一件一件的忙完，学期似乎也到了尾声，某老师也开始布置他那为难人的 php 作业，好在今年的难度比去年的低了很多，不过大多数的同学还是不是很懂，也因此我弄了个公众号，写了一些作业相关的文章。不得不吐槽一下，我知道老师你很牛逼，但是也不用每节课都花那么长的时间夸你自己吧，凡尔赛实锤了。</p>
<p>弄完了作业，结束了考试，考试期间一时兴起，又弄了个静态网站，因为买的服务器要到期了，我又穷，就用 Hexo + GitHub 弄了个博客，大佬的框架就是香啊，博客地址：<a href="https://zeroclian.github.io/">https://zeroclian.github.io/</a></p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231222849876.png"></p>
<p>2020年就这么结束了，不知道2021会怎么样，但是希望未来的日子能够充满阳光。</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20201231223446172.png" alt="I Love you. YCL&amp;LRY"></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈 MySQL 事务</title>
    <url>/posts/d98c058a.html</url>
    <content><![CDATA[<h1 id="浅谈-MySQL-事务"><a href="#浅谈-MySQL-事务" class="headerlink" title="浅谈 MySQL 事务"></a>浅谈 MySQL 事务</h1><hr>
<h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><ul>
<li>事务是逻辑上的一组操作，要么全部执行，要么都不执行</li>
</ul>
<h2 id="事务的四大特性"><a href="#事务的四大特性" class="headerlink" title="事务的四大特性"></a>事务的四大特性</h2><ul>
<li>原子性（Atomicity）：事务是最小的执行单位，不允许分割，原子性保证事务的动作要么全部成功，要么全部失败。</li>
<li>一致性（Consistency）：执行事务前后，数据保持一致，多个事务对数据读取的结果是一致的。</li>
<li>隔离性（Isolation）：并发访问数据库时，一个用户的事务不被其他事务所干扰，各种并发事务之间数据库是独立的。</li>
<li>持久性（Durability）：一个事务被提交后，对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何的影响。</li>
</ul>
<h2 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h2><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同⼀数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p>
<ul>
<li>脏读（<strong>Dirty read</strong>）:当⼀个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外⼀个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外⼀个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。</li>
<li>丢失修改（<strong>Lost to modify</strong>）: 指在⼀个事务读取⼀个数据时，另外⼀个事务也访问了该数据，那么在第⼀个事务中修改了这个数据后，第⼆个事务也修改了这个数据。这样第⼀个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。</li>
<li>不可重复读（<strong>Unrepeatableread</strong>）: 指在⼀个事务内多次读同⼀数据。在这个事务还没有结束时，另⼀个事务也访问该数据。那么，在第⼀个事务中的两次读数据之间，由于第⼆个事务的修改导致第⼀个事务两次读取的数据可能不太⼀样。这就发⽣了在⼀个事务内两次读到的数据是不⼀样的情况，因此称为不可重复读。</li>
<li>幻读（<strong>Phantom read</strong>）: 幻读与不可重复读类似。它发⽣在⼀个事务（T1）读取了⼏⾏数据，接着另⼀个并发事务（T2）插⼊了⼀些数据时。在随后的查询中，第⼀个事务（T1）就会发现多了⼀些原本不存在的记录，就好像发⽣了幻觉⼀样，所以称为幻读。</li>
</ul>
<p><strong>不可重复读和幻读区别：</strong></p>
<p>​        不可重复读的重点是修改⽐如多次读取⼀条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除⽐如多次读取⼀条记录发现记录增多或减少了。</p>
<hr>
<h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>SQL 标准定义了四个隔离级别：</p>
<ul>
<li>READ-UNCOMMITTED(读取未提交)：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li>
<li>READ-COMMITTED(读取已提交)： 允许读取并发事务已经提交的数据，可以阻⽌脏读，但是幻读或不可重复读仍有可能发⽣。</li>
<li>REPEATABLE-READ(可重复读)： 对同⼀字段的多次读取结果都是⼀致的，除⾮数据是被本身事务⾃⼰所修改，可以阻⽌脏读和不可重复读，但幻读仍有可能发⽣。</li>
<li>SERIALIZABLE(可串⾏化)： 最⾼的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执⾏，这样事务之间就完全不可能产⽣⼲扰，也就是说，该级别可以防⽌脏读、不可重复读以及幻读。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210102165004946.png" alt="隔离级别"></p>
<p>MySQL InnoDB 存储引擎的默认⽀持的隔离级别是 <strong>REPEATABLE-READ</strong>（可重读）。我们可以通过<code>SELECT @@tx_isolation;</code> 命令来查看。</p>
<p>InnoDB 存储引擎在<strong>分布式事务</strong>的情况下，一般会用到**SERIALIZABLE(可串行化)**隔离级别。</p>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>浅谈锁优化</title>
    <url>/posts/1e489958.html</url>
    <content><![CDATA[<h2 id="浅谈锁优化"><a href="#浅谈锁优化" class="headerlink" title="浅谈锁优化"></a>浅谈锁优化</h2><div class="note blue icon simple"><i class="note-icon fas fa-bullhorn"></i><p>参考阅读</p>
<p><a href="https://www.jianshu.com/p/36eedeb3f912">https://www.jianshu.com/p/36eedeb3f912</a></p>
<p><a href="https://blog.dreamtobe.cn/2015/11/13/java_synchronized/">https://blog.dreamtobe.cn/2015/11/13/java_synchronized/</a></p>
</div>

<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>锁消除是指虚拟机即时编译在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。锁消除主要依据<strong>逃逸分析</strong>的数据支持，如果判断在一段代码上，堆上所有数据都不会逃逸出去从而被其他线程访问到，那么就可以把它们当作栈上数据，即认为它们是私有的，同步加锁则无需进行。</p>
<h3 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h3><p>原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p>
<p>大部分情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，那么即使没有线程竞争，频繁的互斥同步操作也会带来很多不必要的性能消耗。</p>
<p>锁粗化会把加锁同步的范围扩展（粗化）到整个操作序列的外部，这样只需要加锁一次。</p>
<h3 id="自旋锁、自适应自旋锁"><a href="#自旋锁、自适应自旋锁" class="headerlink" title="自旋锁、自适应自旋锁"></a>自旋锁、自适应自旋锁</h3><p>很多时候共享数据的锁定状态只会持续很短时间，为了这段时间去挂起和恢复线程并不值得（挂起和恢复线程需要从用户态切换到内核态，对性能的开销很大）。因此让请求锁的<strong>线程等待（自旋）</strong>，看持有锁的线程是否很快释放锁，自旋等待不能代替阻塞，因为自旋虽然避免了切换线程的开销，却要占用处理器时间，当等待时间很短，自旋效果就会很好，反之只会白白消耗处理器资源。</p>
<p>因此自旋等待的时间必须有一定的限制，自旋的默认次数是10，通过<code>-XX:PreBlockSpin</code> 参数修改，但是用户很难感知<strong>锁竞争时间</strong>，如果设置的自旋次数不合理，依然会造成资源浪费，所以出现了<strong>自适应自旋锁</strong>，解决的是锁竞争时间不确定问题。</p>
<p>自适应自旋锁意味着自旋的时间不再固定，而是由<strong>前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定</strong>：</p>
<ul>
<li>如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而它将允许自旋等待持续相对更长的时间，比如100个循环。</li>
<li>相反的，如果对于某个锁，自旋很少成功获得过，那在以后要获取这个锁时将可能减少自旋时间甚至省略自旋过程，以避免浪费处理器资源。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>单核处理器上，不存在实际的并行，当前线程不阻塞自己的话，旧线程不能执行，锁永远不会释放。</li>
<li>自旋锁要占用CPU，如果是计算密集型任务，这一优化通常得不偿失，减少锁的使用是更好的选择。</li>
<li>如果锁竞争的时间比较长，那么自旋通常不能获得锁，白白浪费了自旋占用的CPU时间。因此发生在<em>锁持有时间长，且竞争激烈</em>的场景中，此时应主动禁用自旋锁。</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>自旋锁的目标是降低线程切换的成本，如果锁竞争激烈，我们不得不依赖于<strong>重量级锁</strong>，让竞争失败的线程阻塞；如果完全没有实际的锁竞争，那么申请重量级锁都是浪费的。</p>
<p>轻量级锁不是为了代替重量级锁，它的本意是<strong>在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗</strong>，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了<strong>CAS操作</strong>。</p>
<p>轻量级锁能够提升程序同步性能的依据是“对于绝大部分锁，在整个同步周期内都是不存在竞争的”，这是一个经验数据。<strong>如果没有竞争，轻量级锁使用 CAS 操作避免了使用互斥操作的开销。但如果存在锁竞争，除了互斥量开销外，还会额外发生CAS操作，因此在有锁竞争的情况下，轻量级锁比传统的重量级锁更慢！</strong>如果锁竞争激烈，那么轻量级将很快膨胀为重量级锁！</p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：<strong>轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉，连CAS操作都不做了。</strong></p>
<p>偏向锁的“偏”就是偏心的偏，它的意思是会偏向于第一个获得它的线程，如果在接下来的执行中，该锁没有被其他线程获取，那么持有偏向锁的线程就不需要进行同步。</p>
<p>但是对于锁竞争比较激烈的场合，偏向锁就失效了，因为这样场合极有可能每次申请锁的线程都是不相同的，因此这种场合下不应该使用偏向锁，否则会得不偿失，需要注意的是，偏向锁失败后，并不会立即膨胀为重量级锁，而是先升级为轻量级锁。</p>
<p>如果需要，使用参数<code>-XX:-UseBiasedLocking</code>禁止偏向锁优化（默认打开）。</p>
<p>锁主要存在四中状态，依次是：<strong>无锁状态</strong>、<strong>偏向锁状态</strong>、<strong>轻量级锁状态</strong>、<strong>重量级锁状态</strong>，他们会随着竞争的激烈而逐渐升级。注意锁<strong>可以升级不可降级</strong>，这种策略是为了提高获得锁和释放锁的效率。</p>
<h3 id="锁升级图解"><a href="#锁升级图解" class="headerlink" title="锁升级图解"></a>锁升级图解</h3><p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/java_synchronized.png" alt="java_synchronized"></p>
<h3 id="锁总结"><a href="#锁总结" class="headerlink" title="锁总结"></a>锁总结</h3><ul>
<li>偏向锁：无实际竞争，且将来只有第一个申请锁的线程会使用锁。</li>
<li>轻量级锁：无实际竞争，多个线程交替使用锁；允许短时间的锁竞争。</li>
<li>重量级锁：有实际竞争，且锁竞争时间长。</li>
</ul>
<p>另外，如果锁竞争时间短，可以使用自旋锁进一步优化轻量级锁、重量级锁的性能，减少线程切换。</p>
<p>如果锁竞争程度逐渐提高（缓慢），那么从偏向锁逐步膨胀到重量锁，能够提高系统的整体性能。</p>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>多线程</category>
      </categories>
      <tags>
        <tag>并发编程</tag>
      </tags>
  </entry>
  <entry>
    <title>面试之——浅谈Spring MVC</title>
    <url>/posts/7981371.html</url>
    <content><![CDATA[<h1 id="面试之——浅谈Spring-MVC"><a href="#面试之——浅谈Spring-MVC" class="headerlink" title="面试之——浅谈Spring MVC"></a>面试之——浅谈Spring MVC</h1><p>MVC 是一种设计模式，Spring MVC 是一款优秀的 MVC 框架，能够帮助我们进行更加便捷的 Web 层开发，在Spring MVC 下我们把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层（控制层，返回数据给前端页面）。</p>
<p>原理图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210102153954018.png" alt="Spring MVC"></p>
<h2 id="Spring-MVC-工作原理"><a href="#Spring-MVC-工作原理" class="headerlink" title="Spring MVC 工作原理"></a>Spring MVC 工作原理</h2><p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210102154259946.png" alt="Spring MVC 工作原理"></p>
<ol>
<li>客户端发送请求，直接请求发送到 <code>DispatcherServlet</code>。</li>
<li> <code>DispatcherServlet</code> 根据请求信息调用 <code>HandlerMapping</code>，解析请求对应的<code>Handler</code>。</li>
<li>解析到对应的 Handler（即 Controller）后，开始由 HandlerAdapter 适配器处理。</li>
<li><code>HandlerAdapter</code> 会根据 <code>Handler</code> 来调用真正的处理器开始处理请求，并处理相应的业务逻辑。</li>
<li>处理器完成业务后，会返回一个 <code>ModelAndView</code> 对象，<code>Model</code> 是返回的数据对象，<code>View</code> 是个逻辑上的 <code>View</code>。</li>
<li><code>ViewResolver</code> 会根据逻辑 <code>View</code> 查找实际的 <code>View</code>。</li>
<li><code>DispaterServlet</code> 把返回的 <code>Model</code> 传给 <code>View</code> （视图渲染）。</li>
<li>把 <code>View</code> 返回给请求者（客户端）。 </li>
</ol>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>简闻——新闻查看APP</title>
    <url>/posts/c8ced817.html</url>
    <content><![CDATA[<h1 id="简闻——新闻查看APP"><a href="#简闻——新闻查看APP" class="headerlink" title="简闻——新闻查看APP"></a>简闻——新闻查看APP</h1><h2 id="一、实现功能"><a href="#一、实现功能" class="headerlink" title="一、实现功能"></a>一、实现功能</h2><ol>
<li>登陆注册</li>
<li>获取和更新新闻</li>
<li>收藏新闻</li>
<li>修改个人信息</li>
</ol>
<h2 id="二、系统整体设计"><a href="#二、系统整体设计" class="headerlink" title="二、系统整体设计"></a>二、系统整体设计</h2><p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210104092832594.png" alt="image-20210104092832594"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210104092906938.png" alt="image-20210104092906938"></p>
<h2 id="三、运行截图"><a href="#三、运行截图" class="headerlink" title="三、运行截图"></a>三、运行截图</h2><p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210104093259955.png" alt="image-20210104093259955"></p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210104093314189.png" alt="image-20210104093314189"></p>
<h4 id="Github地址：https-github-com-LIANYCL-SimpleNews"><a href="#Github地址：https-github-com-LIANYCL-SimpleNews" class="headerlink" title="Github地址：https://github.com/LIANYCL/SimpleNews"></a>Github地址：<a href="https://github.com/LIANYCL/SimpleNews">https://github.com/LIANYCL/SimpleNews</a></h4>]]></content>
      <categories>
        <category>项目</category>
        <category>Android</category>
      </categories>
      <tags>
        <tag>课程设计</tag>
      </tags>
  </entry>
  <entry>
    <title>Java基础</title>
    <url>/posts/f7ede91d.html</url>
    <content><![CDATA[<h2 id="Java基础"><a href="#Java基础" class="headerlink" title="Java基础"></a>Java基础</h2><h3 id="字符常量和字符串常量的区别？"><a href="#字符常量和字符串常量的区别？" class="headerlink" title="字符常量和字符串常量的区别？"></a>字符常量和字符串常量的区别？</h3><ul>
<li>形式上：<ul>
<li>字符常量是单引号引起的一个字符</li>
<li>字符串常量是双引号引起的若干字符</li>
</ul>
</li>
<li>含义上：<ul>
<li>字符常量相当于一个 ASCII 值，能参与计算</li>
<li>字符串常量代表一个地址（字符串常量存放地址）</li>
</ul>
</li>
<li>大小上：<ul>
<li>字符常量只占2个字节</li>
<li>字符串常量若干字节</li>
</ul>
</li>
</ul>
<h3 id="重写和重载的区别？"><a href="#重写和重载的区别？" class="headerlink" title="重写和重载的区别？"></a>重写和重载的区别？</h3><ul>
<li>重写：发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。<ul>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则⼦类就不能重写该方法，但是被 static修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ul>
</li>
<li>重载：在同一个类中多个同名方法根据不同的传参来执行不同的逻辑处理。</li>
</ul>
<table>
<thead>
<tr>
<th>区别点</th>
<th>重载</th>
<th>重写</th>
</tr>
</thead>
<tbody><tr>
<td>发生范围</td>
<td>同个类</td>
<td>子类</td>
</tr>
<tr>
<td>参数列表</td>
<td>必须修改</td>
<td>不能修改</td>
</tr>
<tr>
<td>返回类型</td>
<td>可修改</td>
<td>不能修改</td>
</tr>
<tr>
<td>异常</td>
<td>可修改</td>
<td>可以缩小异常范围</td>
</tr>
<tr>
<td>访问修饰符</td>
<td>可修改</td>
<td>可以降低限制</td>
</tr>
<tr>
<td>发生阶段</td>
<td>编译器</td>
<td>运行期</td>
</tr>
</tbody></table>
<h3 id="String、StringBuffer-和-StringBuilder-的区别？"><a href="#String、StringBuffer-和-StringBuilder-的区别？" class="headerlink" title="String、StringBuffer 和 StringBuilder 的区别？"></a>String、StringBuffer 和 StringBuilder 的区别？</h3>]]></content>
      <categories>
        <category>面试必备</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>基础知识</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker 详解</title>
    <url>/posts/9683a4f7.html</url>
    <content><![CDATA[<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>基于 Centos 7 系统的安装步骤</p>
<ol>
<li>yum 包更新到最新<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br></pre></td></tr></table></figure></li>
<li>安装需要的软件包，yum-util 提供 yum-config-manager 功能，另外两个是 devicemapper 驱动依赖的<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure></li>
<li>设置 yum 源为阿里云<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure></li>
<li>安装 docker<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure></li>
<li>查看安装后的版本<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="设置-ustc-的镜像"><a href="#设置-ustc-的镜像" class="headerlink" title="设置 ustc 的镜像"></a>设置 ustc 的镜像</h1><ol>
<li><p>编辑文件：<code>vi /etc/docker/daemon.json</code></p>
</li>
<li><p>添加如下内容</p>
</li>
</ol>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line"><span class="attr">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://docker.mirrors.ustc.edu.cn&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="Docker-的启动与停止"><a href="#Docker-的启动与停止" class="headerlink" title="Docker 的启动与停止"></a>Docker 的启动与停止</h1><ol>
<li>启动 docker：<code>systemctl start docker</code></li>
<li>停止 docker：<code>systemctl stop docker</code></li>
<li>重启 docker：<code>systemctl restart docker</code></li>
<li>查看 docker 状态：<code>systemctl status docker</code></li>
<li>开机启动：<code>systemctl enable docker</code></li>
<li>查看 docker 概要信息：<code>docker info</code></li>
<li>查看帮助文档：<code>docker --help</code></li>
</ol>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><h2 id="镜像相关命令"><a href="#镜像相关命令" class="headerlink" title="镜像相关命令"></a>镜像相关命令</h2><h3 id="查看镜像-docker-images"><a href="#查看镜像-docker-images" class="headerlink" title="查看镜像: docker images"></a>查看镜像: <code>docker images</code></h3><p>这些镜像都是存储在 Docker 宿主机的 /var/lib/docker 目录下</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">repository</td>
<td align="center">镜像名称</td>
</tr>
<tr>
<td align="center">tag</td>
<td align="center">镜像标签</td>
</tr>
<tr>
<td align="center">image id</td>
<td align="center">镜像ID</td>
</tr>
<tr>
<td align="center">created</td>
<td align="center">镜像创建日期</td>
</tr>
<tr>
<td align="center">size</td>
<td align="center">镜像大小</td>
</tr>
</tbody></table>
<h3 id="搜索镜像-docker-search-镜像名称"><a href="#搜索镜像-docker-search-镜像名称" class="headerlink" title="搜索镜像:docker search 镜像名称"></a>搜索镜像:<code>docker search 镜像名称</code></h3><p>通过网络查找需要的镜像</p>
<table>
<thead>
<tr>
<th align="center">属性</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">name</td>
<td align="center">仓科名称</td>
</tr>
<tr>
<td align="center">description</td>
<td align="center">镜像描述</td>
</tr>
<tr>
<td align="center">stars</td>
<td align="center">受欢迎程度</td>
</tr>
<tr>
<td align="center">official</td>
<td align="center">是否官方</td>
</tr>
<tr>
<td align="center">automated</td>
<td align="center">自动构建，表示该镜像由 Docker Hub 自动构建流程创建的</td>
</tr>
</tbody></table>
<h3 id="拉取镜像-docker-pull-镜像名称"><a href="#拉取镜像-docker-pull-镜像名称" class="headerlink" title="拉取镜像:docker pull 镜像名称"></a>拉取镜像:<code>docker pull 镜像名称</code></h3><h3 id="删除镜像-docker-rmi-镜像ID"><a href="#删除镜像-docker-rmi-镜像ID" class="headerlink" title="删除镜像:docker rmi 镜像ID"></a>删除镜像:<code>docker rmi 镜像ID</code></h3><h3 id="删除所有镜像：docker-rmi-39-docker-images-q-39"><a href="#删除所有镜像：docker-rmi-39-docker-images-q-39" class="headerlink" title="删除所有镜像：docker rmi &#39;docker images -q&#39;"></a>删除所有镜像：<code>docker rmi &#39;docker images -q&#39;</code></h3><h2 id="容器相关命令"><a href="#容器相关命令" class="headerlink" title="容器相关命令"></a>容器相关命令</h2><h3 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h3><ol>
<li>查看运行中的容器：<code>docker ps</code></li>
<li>查看所有容器：<code>docker ps -a</code></li>
<li>查看最后一次运行的容器：<code>docker ps -l</code></li>
<li>查看停止的容器：<code>docker ps -f status=exited</code></li>
</ol>
<h3 id="创建与启动容器"><a href="#创建与启动容器" class="headerlink" title="创建与启动容器"></a>创建与启动容器</h3><ul>
<li>命令：<code>docker run</code><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">含义</th>
<th align="center">备注</th>
</tr>
</thead>
<tbody><tr>
<td align="center">-i</td>
<td align="center">表示运行容器</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-t</td>
<td align="center">表示容器启动后会进入其命令行</td>
<td align="center">加入 it 两个参数后，容器创建就能登陆进去，即分配一个伪终端</td>
</tr>
<tr>
<td align="center">–name</td>
<td align="center">为创建的容器命名</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">-v</td>
<td align="center">表示目录映射关系（前者是宿主机目录，后者是映射到宿主机上的目录），可以使用多个 -v 做多个目录或者文件映射</td>
<td align="center">最好做目录映射，在宿主机上做修改，然后共享到容器上</td>
</tr>
<tr>
<td align="center">-d</td>
<td align="center">在 run 后面加上 -d 参数则会创建一个守护式容器在后台运行</td>
<td align="center">这样创建容器后不会自动登陆进去容器</td>
</tr>
<tr>
<td align="center">-p</td>
<td align="center">表示端口映射，前者是宿主机端口，后者是容器内的映射端口，可以使用多个 -p 做多个端口映射</td>
<td align="center"></td>
</tr>
</tbody></table>
</li>
</ul>
<ol>
<li><p>交互式方式创建容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -it --name=容器名称 镜像名称:标签 /bin/bash</span><br></pre></td></tr></table></figure>
<p>退出当前容器：<code>exit</code></p>
</li>
<li><p>守护式方式创建容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">//创建</span><br><span class="line">docker run -id --name=容器名称 镜像名称:标签</span><br><span class="line">//登陆</span><br><span class="line">docker <span class="built_in">exec</span> -it 容器名称（或容器ID）/bin/bash</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h3 id="停止与启动容器"><a href="#停止与启动容器" class="headerlink" title="停止与启动容器"></a>停止与启动容器</h3><ul>
<li>停止容器：<code>docker stop 容器名称（或容器ID）</code></li>
<li>启动容器：<code>docker start 容器名称（或容器ID）</code></li>
</ul>
<h3 id="文件拷贝"><a href="#文件拷贝" class="headerlink" title="文件拷贝"></a>文件拷贝</h3><ul>
<li>拷贝到容器：<code>docker cp 需要拷贝的文件或目录 容器名称:容器目录</code></li>
<li>从容器中拷贝：<code>docker cp 容器名称:容器目录 需要拷贝的文件或目录</code></li>
</ul>
<h3 id="目录挂载"><a href="#目录挂载" class="headerlink" title="目录挂载"></a>目录挂载</h3><p>在创建容器的时候，将宿主机的目录与容器内的目录进行映射，从而可以通过修改宿主机某个目录的文件去影响容器。<br>在创建容器时，添加 -v 宿主机目录 : 容器目录，如：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -id -v /usr/<span class="built_in">local</span>/myhtml:/usr/<span class="built_in">local</span>/myhtml --name=mycentos centos:7</span><br></pre></td></tr></table></figure>
<p>如果共享的是多级目录，可能会出现权限不足的提示，这是因为 CentOS 7 中的安全模块 selinux 把权限禁掉了，因此需要添加参数 –privileged=true 来解决挂载的目录没用权限的问题。</p>
<h3 id="查看容器IP地址"><a href="#查看容器IP地址" class="headerlink" title="查看容器IP地址"></a>查看容器IP地址</h3><ul>
<li>查看容器运行的各种数据：<code>docker inspect 容器名称（容器ID）</code></li>
<li>直接输出IP地址：<code>docker inspect --format=&#39;&#123;&#123;.NetworkSettings.IPaddress&#125;&#125;&#39; 容器名称（容器ID）</code></li>
</ul>
<h3 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h3><ul>
<li>删除指定容器：<code>docker rm 容器名称（容器ID）</code></li>
</ul>
<h1 id="应用部署"><a href="#应用部署" class="headerlink" title="应用部署"></a>应用部署</h1><h2 id="MySQL-部署"><a href="#MySQL-部署" class="headerlink" title="MySQL 部署"></a>MySQL 部署</h2><ol>
<li>拉取镜像<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull centos/mysql-57-centos7</span><br></pre></td></tr></table></figure></li>
<li>创建容器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -id --name=tensquare_mysql -p 33306:3306 -e MYSQL_ROOT_PASSWORD=123456 centos/mysql-57-centos7</span><br></pre></td></tr></table></figure>
<code>-e</code> 代表添加环境变量 MYSQL_ROOT_PASSWORD 是 root 用户的登陆密码<br><code>-p</code> 代表端口映射</li>
</ol>
<ol start="3">
<li><p>进入 mysql 容器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it tensquare_mysql /bin/bash</span><br></pre></td></tr></table></figure></li>
<li><p>登陆 mysql</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure></li>
<li><p>远程登陆 mysql</p>
<p>连接宿主机 IP ，指定端口为 33306</p>
</li>
</ol>
<h2 id="tomcat部署"><a href="#tomcat部署" class="headerlink" title="tomcat部署"></a>tomcat部署</h2><ol>
<li>拉取镜像：<code>docker pull tomcat:7-jre7</code></li>
<li>创建容器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=mytomcat -p 9000:8080 -v /usr/<span class="built_in">local</span>/webapps:/usr/<span class="built_in">local</span>/tomcat/webapps tomcat:7-jre7</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Nginx部署"><a href="#Nginx部署" class="headerlink" title="Nginx部署"></a>Nginx部署</h2><ol>
<li>拉取镜像：<code>docker pull nginx</code></li>
<li>创建容器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=mynginx -p 80:80 nginx</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h2 id="Redis部署"><a href="#Redis部署" class="headerlink" title="Redis部署"></a>Redis部署</h2><ol>
<li>拉取镜像：<code>docker pull redis</code></li>
<li>创建容器<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -di --name=myredis -p 6379:6379 redis</span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="迁移与备份"><a href="#迁移与备份" class="headerlink" title="迁移与备份"></a>迁移与备份</h1><ol>
<li>容器保存为镜像<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker commit mynginx mynginx_i</span><br></pre></td></tr></table></figure></li>
<li>镜像备份<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker save -o mynginx.tar mynginx_i</span><br></pre></td></tr></table></figure></li>
<li>镜像恢复与迁移<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker load -i mynginx.tar</span><br></pre></td></tr></table></figure>
    <code>-i</code> 输入的文件</li>
</ol>
<h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>Dockerfile 是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像。</p>
<ol>
<li>对于开发人员：可以为开发团队提供一个完全一致的开发环境</li>
<li>对于测试时人员：可以直接拿开发时所构建的镜像或通过 Dockerfile 文件构建一个新的镜像开始工作</li>
<li>对于运维人员：在部署时，可以实现应用的无缝移植</li>
</ol>
<h2 id="常用命令-1"><a href="#常用命令-1" class="headerlink" title="常用命令"></a>常用命令</h2><table>
<thead>
<tr>
<th align="center">命令</th>
<th align="center">作用</th>
</tr>
</thead>
<tbody><tr>
<td align="center">FROM image_name:tag</td>
<td align="center">定义了使用哪个基础镜像启动构建流程</td>
</tr>
<tr>
<td align="center">MAINTAINER user_name</td>
<td align="center">声明镜像的创建者</td>
</tr>
<tr>
<td align="center">ENV key value</td>
<td align="center">设置环境变量（可以写多条）</td>
</tr>
<tr>
<td align="center">RUN command</td>
<td align="center">是 Dockerfile 的核心部分（可以写多条）</td>
</tr>
<tr>
<td align="center">ADD source_dir/file dest_dir/file</td>
<td align="center">将宿主机的文件复制到容器内，如果是一个压缩文件，将会在复制完成后自动解压</td>
</tr>
<tr>
<td align="center">COPY source_dir/file dest_dir/file</td>
<td align="center">和ADD相似，但是不会解压</td>
</tr>
<tr>
<td align="center">WORKDIR path_dir</td>
<td align="center">设置工作目录</td>
</tr>
</tbody></table>
<h2 id="使用脚本创建镜像"><a href="#使用脚本创建镜像" class="headerlink" title="使用脚本创建镜像"></a>使用脚本创建镜像</h2><ol>
<li><p>创建 Dockerfile 文件 <code>vi Dockerfile</code>（以 jdk 为例）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">FROM centos:7</span><br><span class="line">MAINTAINER ZeroClian</span><br><span class="line"><span class="comment">#切换工作目录</span></span><br><span class="line">WORKDIR /usr</span><br><span class="line">RUN mkdir /usr/<span class="built_in">local</span>/java</span><br><span class="line">ADD jdk......gz /usr/<span class="built_in">local</span>/java/</span><br><span class="line"><span class="comment">#配置Java环境变量</span></span><br><span class="line">ENV JAVA_HOME /usr/<span class="built_in">local</span>/java/jdkxxxxx</span><br><span class="line">ENV JRE_HOME <span class="variable">$JAVA_HOME</span>/jre</span><br><span class="line">ENV CLASSPATH <span class="variable">$JAVA_HOME</span>/bin/dt.jar:<span class="variable">$JAVA_HOME</span>/lib/tools.jar:<span class="variable">$JRE_HOME</span>/lib:<span class="variable">$CLASSPATH</span></span><br><span class="line">ENV PATH <span class="variable">$JAVA_HOME</span>/bin/:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure></li>
<li><p>构建命令：<code>docker build -t=&#39;jdk1.8&#39; .</code></p>
<p><code>. </code>表示在当前目录下寻找 Dockerfile 文件</p>
</li>
<li><p>查看镜像是否建立完成：<code>docker images</code></p>
</li>
</ol>
<h1 id="Docker-私有仓库"><a href="#Docker-私有仓库" class="headerlink" title="Docker 私有仓库"></a>Docker 私有仓库</h1><h2 id="建立私有仓库与配置"><a href="#建立私有仓库与配置" class="headerlink" title="建立私有仓库与配置"></a>建立私有仓库与配置</h2><ol>
<li><p>拉取私有仓库镜像：<code>docker pull registry</code></p>
</li>
<li><p>启动私有仓库容器：<code>docker run -di --name=registry -p 5000:5000 registry</code></p>
</li>
<li><p>打开浏览器输入地址<a href="http://192.168.63.128:5000/v2/_catalog">http://192.168.63.128:5000/v2/_catalog</a>看到<code>&#123;&quot;repositories&quot;:[]&#125;</code>表示私有仓库搭建成功并且内容为空</p>
</li>
<li><p>修改 daemon.json</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#修改</span></span><br><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"><span class="comment">#添加以下内容，保存退出</span></span><br><span class="line">&#123;<span class="string">&quot;insecure-registries&quot;</span>:[<span class="string">&quot;192.168.63.128:5000&quot;</span>]&#125;</span><br></pre></td></tr></table></figure>
<p>此步用于让 docker 信任私有仓库地址（要加逗号）</p>
</li>
<li><p>重启 docker 服务：<code>systemctl restart docker</code></p>
</li>
</ol>
<h2 id="镜像上传至私有仓库"><a href="#镜像上传至私有仓库" class="headerlink" title="镜像上传至私有仓库"></a>镜像上传至私有仓库</h2><ol>
<li>标记此镜像为私有仓库的镜像<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker tag jdk1.8 192.168.63.128:5000/jdk1.8</span><br></pre></td></tr></table></figure></li>
<li>上传标记的镜像<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker push 192.168.63.128:5000/jdk1.8</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li>拉取：<code>docker pull 192.168.63.128:5000/jdk1.8</code></li>
</ul>
]]></content>
      <categories>
        <category>容器</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL存储引擎——浅谈</title>
    <url>/posts/ca4da212.html</url>
    <content><![CDATA[<h1 id="MySQL存储引擎——浅谈"><a href="#MySQL存储引擎——浅谈" class="headerlink" title="MySQL存储引擎——浅谈"></a>MySQL存储引擎——浅谈</h1><ul>
<li><p>主要的存储引擎有 <strong>InnoDB</strong> 、<strong>MyISAM</strong> 、Memory 、blackhole 、TokuDB 和 MariaDB columnstore。</p>
</li>
<li><p>最主流的两个引擎对比，可以看出 InnoDB 引擎的优势很明显。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>区别</th>
<th>InnoDB</th>
<th>MyISAM</th>
</tr>
</thead>
<tbody><tr>
<td>事务的支持</td>
<td>支持事务</td>
<td>不支持事务</td>
</tr>
<tr>
<td>锁粒度</td>
<td>行锁</td>
<td>表锁</td>
</tr>
<tr>
<td>并发性</td>
<td>高并发（支持MVCC）</td>
<td>低并发</td>
</tr>
<tr>
<td>select count(*)</td>
<td>需要扫描全表，统计所有行数</td>
<td>只需从计数器中读取出保存好的行数即可</td>
</tr>
</tbody></table>
<ul>
<li>MySQL 数据库是一个<strong>单进程多线程模型</strong>的数据库。</li>
<li>5.5版本以前，MyISAM是MySQL的默认数据库，虽然性能极佳，提供了大量特性，包括全文索引、压缩、空间函数等，但是不支持事务以及行级锁，崩溃后无法安全恢复。因此之后的版本引入InnoDB作为默认的存储引擎。</li>
</ul>
<h2 id="InnoDB-的三大特性"><a href="#InnoDB-的三大特性" class="headerlink" title="InnoDB 的三大特性"></a>InnoDB 的三大特性</h2><ul>
<li>插入缓存</li>
</ul>
<p>影响数据库最主要的性能问题就是 I/O，而插入缓存的作用就是把普通索引上的 DML（如insert,delete,update,select等）操作从随机 I/O变成顺序 I/O，提高 I/O 的效率。其工作原理就是先判断插入的普通索引页是否在缓存池中，如果在直接插入，如果不在就先放到 change buffer 中，然后进行 change buffer 和普通索引的合并操作，这样可以将多个插入合并到一个操作中，一下子提高了普通索引的插入性能。</p>
<ul>
<li>两次写</li>
</ul>
<p>保证写入的安全性，防止在 MySQL 实例发生宕机时，InnoDB 发生数据页部分页写的问题。</p>
<ul>
<li>自适应哈希索引</li>
</ul>
<p>InnoDB 存储引擎有一个机制，可以监控索引的搜索，如果 InnoDB 注意到查询可以通过建立哈希索引得到优化，那么就会自动完成这件事。</p>
<ul>
<li>预读</li>
</ul>
<p>InnoDB 中将64个页划分为一个 extent，当一个 extent 中的页，被顺序读超过了多少个，比如50个，这个值是可以通过nnodb_read_ahead_threshold 设置的，那么就会认为顺序读到下一个 extent 的可能性很大，会提前将下一个 extent 中的所有页都加载到 buffer pool 中，这叫线性预读</p>
<p>如果某一个 extent 中，有多个页被读到，就会认为读到这个 extent 中其他页的可能性也很大，就会把该 extent 中的其他页也都提前读到 buffer pool 中。</p>
<p>这些特性让 InnoDB 存储引擎有了更好的性能和可靠性。 </p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>MySQL索引使用的数据结构主要有BTree索引和哈希索引。</p>
<p>当绝大多数需求为单条记录查询时，可以选择哈希索引，查询效率最快；其余场景建议使用BTree索引。</p>
<p>两种引擎对BTree索引（B+Tree）的实现方式不同：</p>
<ul>
<li>MyISAM：B+Tree叶节点的<code>data</code>域存放的是数据记录的地址，在检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的key存在，则取出其data域值，然后以data域的值为地址读取相应的数据。这被称为“非聚簇索引”。</li>
<li>InnoDB：其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的⼀个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集 索引）”。而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。<strong>在根据主索引搜索时，直接找到key所在的节点即可取出数 据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时 候，不建议使用过长的字段作为主键，也不建议使而非单调的字段作为主键，这样会造成主索引频繁分裂。</strong></li>
</ul>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>ArrayList源码分析</title>
    <url>/posts/c352a0f3.html</url>
    <content><![CDATA[<h1 id="ArrayList源码分析"><a href="#ArrayList源码分析" class="headerlink" title="ArrayList源码分析"></a>ArrayList源码分析</h1><p>总所周知，ArrayList的数据结构是基于数组实现，其底层是一个Object数组列表，与我们普通定义的数组不同，它具有动态扩容、数据拷贝等操作。</p>
<p>接下来从初始化、插入、删除等源码来分析ArrayList是如何具体实现这些操作的</p>
<h2 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//默认容量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//创建Object数组</span></span><br><span class="line">        <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;Illegal Capacity: &quot;</span>+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可以看出，<strong>EMPTY_ELEMENTDATA</strong>是一个定义好的空对象，当无参或者大小为0时，将会得到一个Object[]的空对象。</p>
<p>常用的构造方式</p>
<ul>
<li>普通方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">list.add(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">list.add(<span class="string">&quot;c&quot;</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>Arrays.asList 方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList list = <span class="keyword">new</span> ArrayList(Arrays.asList(<span class="string">&quot;a&quot;</span>,<span class="string">&quot;b&quot;</span>,<span class="string">&quot;c&quot;</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li>Collections.nCopies 方式</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">ArrayList&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;(Collections.nCopies(<span class="number">3</span>,<span class="string">&quot;a&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>Collections.nCopies 是集合方法中用于生成多少份某个指定元素的方法。</p>
<h2 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    elementData[size++] = e;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中，可以看出，插入时分两步：</p>
<ul>
<li>第一步：判断容量是否足够，不足则扩容</li>
<li>第二步：将元素插入，size自增</li>
</ul>
<p>扩容源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ensureExplicitCapacity(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">        grow(minCapacity);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// overflow-conscious code</span></span><br><span class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>核心扩容方法是调用grow方法，扩容后长度为<code> oldCapacity + (oldCapacity &gt;&gt; 1)</code>，即为原来的1.5倍。数组元素的拷贝使用的<code>Arrays.copyOf(elementData, newCapacity)</code>，其底层采用的<code>System.arraycopy</code>。</p>
<p>指定位置插入同理：</p>
<ul>
<li>判断size是否可以插入</li>
<li>判断插入后是否需要扩容</li>
<li>数据迁移，把从待插入位置后面的元素顺序往后迁移</li>
<li>给指定位置赋值</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">    System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                     size - index);</span><br><span class="line">    elementData[index] = element;</span><br><span class="line">    size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    rangeCheck(index);</span><br><span class="line"></span><br><span class="line">    modCount++;</span><br><span class="line">    E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">        System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                         numMoved);</span><br><span class="line">    elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> oldValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>校验是否越界：<code>rangeCheck(index)</code></li>
<li>计算删除元素的移动长度<code>numMoved</code>，并通过<code>System.arraycopy</code>复制元素给自己</li>
<li>结尾元素清空，null</li>
</ul>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><blockquote>
<p>如果给你一组元素；a、b、c、d、e、f、g，需要你放到 ArrayList 中，但是要求 获取一个元素的时间复杂度都是 O(1)，你怎么处理？</p>
</blockquote>
<p>想解决这个问题，就需要知道元素添加到集合中后知道它的位置，而这个位置呢， 其实可以通过哈希值与集合长度与运算，得出存放数据的下标，如下图；</p>
<p><img src="https://cdn.jsdelivr.net/gh/ZeroClian/picture/img/image-20210421134406953.png" alt="image-20210421134406953"></p>
<ul>
<li>如图就是计算出每一个元素应该存放的位置，这样就可以 O(1)复杂度获取元素。</li>
</ul>
]]></content>
      <categories>
        <category>面试必备</category>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
</search>
